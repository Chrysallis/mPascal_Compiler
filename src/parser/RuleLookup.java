package parser;
import java.util.HashMap;
import java.util.Map;

public class RuleLookup {
    private static final HashMap<Integer, String> rules = new HashMap<Integer, String>();
    static {
        rules.put(1, "<SystemGoal> ⟶ <Program> EOF");
        rules.put(2, "<Program> ⟶ <ProgramHeading> ; <Block> .");
        rules.put(3, "<ProgramHeading> ⟶ program <ProgramIdentifier>");
        rules.put(4, "<Block> ⟶ <VariableDeclarationPart> <ProcedureAndFunctionDeclarationPart> <StatementPart>");
        rules.put(5, "<VariableDeclarationPart> ⟶ var <VariableDeclaration> ; <VariableDeclarationTail>");
        rules.put(6, "<VariableDeclarationPart> ⟶ lambda");
        rules.put(7, "<VariableDeclarationTail> ⟶ <VariableDeclaration> ; <VariableDeclarationTail>");
        rules.put(8, "<VariableDeclarationTail> ⟶ lambda");
        rules.put(9, "<VariableDeclaration> ⟶ <IdentifierList> : <Type>");
        rules.put(10, "<Type> ⟶ Integer");
        rules.put(11, "<Type> ⟶ Float");
        rules.put(12, "<Type> ⟶ String");
        rules.put(13, "<Type> ⟶ Boolean");
        rules.put(14, "<ProcedureAndFunctionDeclarationPart> ⟶ <ProcedureDeclaration> <ProcedureAndFunctionDeclarationPart>");
        rules.put(15, "<ProcedureAndFunctionDeclarationPart> ⟶ <FunctionDeclaration> <ProcedureAndFunctionDeclarationPart>");
        rules.put(16, "<ProcedureAndFunctionDeclarationPart> ⟶ lambda");
        rules.put(17, "<ProcedureDeclaration> ⟶ <ProcedureHeading> ; <Block> ;");
        rules.put(18, "<FunctionDeclaration> ⟶ <FunctionHeading> ; <Block> ;");
        rules.put(19, "<ProcedureHeading> ⟶ procedure <ProcedureIdentifier> <OptionalFormalParameterList>");
        rules.put(20, "<FunctionHeading> ⟶ function <FunctionIdentifier> <OptionalFormalParameterList> : <Type>");
        rules.put(21, "<OptionalFormalParameterList> ⟶ ( <FormalParameterSection> <FormalParameterSectionTail> )");
        rules.put(22, "<OptionalFormalParameterList> ⟶ lambda");
        rules.put(23, "<FormalParameterSectionTail> ⟶ ; <FormalParameterSection> <FormalParameterSectionTail>");
        rules.put(24, "<FormalParameterSectionTail> ⟶ lambda");
        rules.put(25, "<FormalParameterSection> ⟶ <ValueParameterSection>");
        rules.put(26, "<FormalParameterSection> ⟶ <VariableParameterSection>");
        rules.put(27, "<ValueParameterSection> ⟶ <IdentifierList> : <Type>");
        rules.put(28, "<VariableParameterSection> ⟶ var <IdentifierList> : <Type>");
        rules.put(29, "<StatementPart> ⟶ <CompoundStatement>");
        rules.put(30, "<CompoundStatement> ⟶ begin <StatementSequence> end");
        rules.put(31, "<StatementSequence> ⟶ <Statement> <StatementTail>");
        rules.put(32, "<StatementTail> ⟶ ; <Statement> <StatementTail>");
        rules.put(33, "<StatementTail> ⟶ lambda");
        rules.put(34, "<Statement> ⟶ <EmptyStatement>");
        rules.put(35, "<Statement> ⟶ <CompoundStatement>");
        rules.put(36, "<Statement> ⟶ <ReadStatement>");
        rules.put(37, "<Statement> ⟶ <WriteStatement>");
        rules.put(38, "<Statement> ⟶ <AssignmentStatement>");
        rules.put(39, "<Statement> ⟶ <IfStatement>");
        rules.put(40, "<Statement> ⟶ <WhileStatement>");
        rules.put(41, "<Statement> ⟶ <RepeatStatement>");
        rules.put(42, "<Statement> ⟶ <ForStatement>");
        rules.put(43, "<Statement> ⟶ <ProcedureStatement>");
        rules.put(44, "<EmptyStatement> ⟶ lambda");
        rules.put(45, "<ReadStatement> ⟶ read ( <ReadParameter> <ReadParameterTail> )");
        rules.put(46, "<ReadParameterTail> ⟶ , <ReadParameter> <ReadParameterTail>");
        rules.put(47, "<ReadParameterTail> ⟶ lambda");
        rules.put(48, "<ReadParameter> ⟶ <VariableIdentifier>");
        rules.put(49, "<WriteStatement> ⟶ write ( <WriteParameter> <WriteParameterTail> )");
        rules.put(50, "<WriteStatement> ⟶ writeln ( <WriteParameter> <WriteParameterTail> )");
        rules.put(51, "<WriteParameterTail> ⟶ , <WriteParameter> <WriteParameterTail>");
        rules.put(52, "<WriteParameterTail> ⟶ lambda");
        rules.put(53, "<WriteParameter> ⟶ <OrdinalExpression>");
        rules.put(54, "<AssignmentStatement> ⟶ <VariableIdentifier> := <Expression>");
        rules.put(55, "<AssignmentStatement> ⟶ <FunctionIdentifier> := <Expression>");
        rules.put(56, "<IfStatement> ⟶ if <BooleanExpression> then <Statement> <OptionalElsePart>");
        rules.put(57, "<OptionalElsePart> ⟶ else <Statement>");
        rules.put(58, "<OptionalElsePart> ⟶ lambda");
        rules.put(59, "<RepeatStatement> ⟶ repeat <StatementSequence> until <BooleanExpression>");
        rules.put(60, "<WhileStatement> ⟶ while <BooleanExpression> do <Statement>");
        rules.put(61, "<ForStatement> ⟶ for <ControlVariable> := <InitialValue> <StepValue> <FinalValue> do <Statement>");
        rules.put(62, "<ControlVariable> ⟶ <VariableIdentifier>");
        rules.put(63, "<InitialValue> ⟶ <OrdinalExpression>");
        rules.put(64, "<StepValue> ⟶ to");
        rules.put(65, "<StepValue> ⟶ downto");
        rules.put(66, "<FinalValue> ⟶ <OrdinalExpression>");
        rules.put(67, "<ProcedureStatement> ⟶ <ProcedureIdentifier> <OptionalActualParameterList>");
        rules.put(68, "<OptionalActualParameterList> ⟶ ( <ActualParameter> <ActualParameterTail> )");
        rules.put(69, "<OptionalActualParameterList> ⟶ lambda");
        rules.put(70, "<ActualParameterTail> ⟶ , <ActualParameter> <ActualParameterTail>");
        rules.put(71, "<ActualParameterTail> ⟶ lambda");
        rules.put(72, "<ActualParameter> ⟶ <OrdinalExpression>");
        rules.put(73, "<Expression> ⟶ <SimpleExpression> <OptionalRelationalPart>");
        rules.put(74, "<OptionalRelationalPart> ⟶ <RelationalOperator> <SimpleExpression>");
        rules.put(75, "<OptionalRelationalPart> ⟶ lambda");
        rules.put(76, "<RelationalOperator> ⟶ =");
        rules.put(77, "<RelationalOperator> ⟶ <");
        rules.put(78, "<RelationalOperator> ⟶ >");
        rules.put(79, "<RelationalOperator> ⟶ <=");
        rules.put(80, "<RelationalOperator> ⟶ >=");
        rules.put(81, "<RelationalOperator> ⟶ <>");
        rules.put(82, "<SimpleExpression> ⟶ <OptionalSign> <Term> <TermTail>");
        rules.put(83, "<TermTail> ⟶ <AddingOperator> <Term> <TermTail>");
        rules.put(84, "<TermTail> ⟶ lambda");
        rules.put(85, "<OptionalSign> ⟶ +");
        rules.put(86, "<OptionalSign> ⟶ -");
        rules.put(87, "<OptionalSign> ⟶ lambda");
        rules.put(88, "<AddingOperator> ⟶ +");
        rules.put(89, "<AddingOperator> ⟶ -");
        rules.put(90, "<AddingOperator> ⟶ or");
        rules.put(91, "<Term> ⟶ <Factor> <FactorTail>");
        rules.put(92, "<FactorTail> ⟶ <MultiplyingOperator> <Factor> <FactorTail>");
        rules.put(93, "<FactorTail> ⟶ lambda");
        rules.put(94, "<MultiplyingOperator> ⟶ *");
        rules.put(95, "<MultiplyingOperator> ⟶ /");
        rules.put(96, "<MultiplyingOperator> ⟶ div");
        rules.put(97, "<MultiplyingOperator> ⟶ mod");
        rules.put(98, "<MultiplyingOperator> ⟶ and");
        rules.put(99, "<Factor> ⟶ unsignedInteger");
        rules.put(100, "<Factor> ⟶ unsignedFloat");
        rules.put(101, "<Factor> ⟶ stringLiteral");
        rules.put(102, "<Factor> ⟶ 1");
        rules.put(103, "<Factor> ⟶ 0");
        rules.put(104, "<Factor> ⟶ not <Factor>");
        rules.put(105, "<Factor> ⟶ ( <Expression> )");
        rules.put(106, "<Factor> ⟶ <FunctionIdentifier> <OptionalActualParameterList>");
        rules.put(107, "<ProgramIdentifier> ⟶ identifier");
        rules.put(108, "<VariableIdentifier> ⟶ identifier");
        rules.put(109, "<ProcedureIdentifier> ⟶ identifier");
        rules.put(110, "<FunctionIdentifier> ⟶ identifier");
        rules.put(111, "<BooleanExpression> ⟶ <Expression>");
        rules.put(112, "<OrdinalExpression> ⟶ <Expression>");
        rules.put(113, "<IdentifierList> ⟶ identifier <IdentifierTail>");
        rules.put(114, "<IdentifierTail> ⟶ , identifier <IdentifierTail>");
        rules.put(115, "<IdentifierTail> ⟶ lambda");
        rules.put(116, "<Factor> ⟶ <VariableIdentifier>");


    }
    public static HashMap getRules(){
        return rules;
    }
    }